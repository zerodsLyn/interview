# 限流

## 1 为什么要限流

单个机器或者集群能够承受的QPS有限，如果超过了阈值，就会导致资源不够用。具体的体现：

​	1）对于接口请求方，服务的相应很慢，超时很多，近乎服务不可用

​	2）对于接口服务方，机器的资源占用量会很大，与注册中心的心跳丢失，相当于节点丢失，对外不提供服务

限流对于系统的稳定性来说是必不可少的。限流是指每秒的请求数目或者字节大小控制在阈值以内，或者限制api的调用次数。

## 2 guava限流器的使用

```xml
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>22.0</version>
</dependency>
```
```java
public class RateLimitTest {
    public static void doSomeLimitedOperation() {
        RateLimiter rateLimiter = RateLimiter.create(2);
        for (int i = 0; i < 5; i++) {
            new Thread(()->{
                while (true) {
                    rateLimiter.acquire();
                    System.out.println(Thread.currentThread().getName() + " invoke " + LocalDateTime.now().getSecond());
                }
            }).start();
        }
    }

    public static void main(String[] args) {
        doSomeLimitedOperation();
    }
}
```

## 3 限流的几种实现算法

### 3.1 简单计数器算法

通过一个`AtomicLong`类型的计数值来进行累加计数。假设QPS设定阈值为100，从第一个请求的时间t (s)开始统计，在t ~ (t+1)这一秒内，每进来一个请求，计数值加1。当计数值超过100后，则接下来拒绝t ~ (t+1)这秒内的其他请求。在(t+1) ~  (t+2)这段时间内，计数值清空，重新进行计数。

问题：

* 无法避免突刺现象
  * 在一定时间内的前一小段时间【100ms】内就用完了所有资源，导致后大部分时间【900ms】中无资源可用
* 限流不精确，在前一秒的后500ms比如说有100个请求，后一秒的500ms有100个请求，这样就导致1s内有200个请求

### 3.2 改良计数器-滑动窗口算法

* 将每秒再划分为多个更加小的小区间。比如每秒划分为5个区间，单独统计每个小区间处理的请求数量。
* 保证每个窗口内的请求数量都是100。窗口随着当前时间向前滑动。

### 3.3 漏桶算法

桶的上部进水，桶底滴水。当进水速度太大，超过桶的容量时，水就会溢出。桶的下部滴水的速度是恒定均匀的。

在实际实现中，桶相当于一个队列，用于缓存请求。每个请求进来，都先缓存到队列中。如果超过队列长度，则拒绝或者返回默认兜底处理。额外一个线程，从队列中已**恒定的速度**取任务。

### 3.4 令牌桶算法

桶中存放的是令牌，有一个令牌工厂以**均匀的速度**往桶里面放令牌。如果超过桶的大小，则丢弃令牌。每个请求进来的时候，都去令牌桶里面申请令牌，如果申请到令牌，则正常执行；否则，拒绝或者返回兜底信息。

## 4 单机限流和集群限流

单机限流是指在单台机器上进行限流，在单个进程上进行限流。而实际的生产环境中，一般是通过集群对外提供服务，一个集群中有多台机器。因此，集群限流会比单机限流困难一些。

* 如果只设置单机限流，那么可能底层的DB扛不住了，每台机器1000qps，3台机器，可是DB只能承受2000QPS

* 如果只设置集群限流，那么可能整个集群是ok的，但是单台机器的负载过高，导致宕机。

